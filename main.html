<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Klein Bottle Game of Life</title>
<style>
    body { margin:0; background:#111; color:#ddd; font-family:monospace; }
    canvas { background:#000; display:block; margin:auto; }
    #ui { position:absolute; top:50px; left:50px; padding:10px; background:#222; }
    #ui input, #ui button, #ui textarea { margin:4px; font-family:monospace; }
</style>
</head>
<body>
<canvas id="mainCanvas"></canvas>
<div id="ui">
    <input type="number" id="numBoards" min="1" value="8">
    <textarea id="twistInput" rows="4" cols="40"></textarea>
    <input type="range" id="speedSlider" min="1" max="30" value="10">
    <button id="restartBtn">Restart</button>
    <button id="applyTwistBtn">Apply Twist</button>
    <button id="toggleUIBtn">Show/Hide UI</button>
    <svg id="graphView" width="400" height="200"></svg>
</div>

<script type="module">
// Config Module
export const gridW=64, gridH=64;
export const cellSize=8;
export const alphaDecay=0.96;
export const defaultZoom=1.0;
export const defaultBoardCount=8;
window.Config={gridW,gridH,cellSize,alphaDecay,defaultZoom,defaultBoardCount};
</script>

<script type="module">
// Grid class
class Grid {
  constructor(w,h){ this.w=w; this.h=h; this.cells=new Array(h).fill(0).map(()=>new Array(w).fill(0)); }
  randomize(p=0.5){ for(let y=0;y<this.h;y++) for(let x=0;x<this.w;x++) this.cells[y][x]=Math.random()<p?1:0; }
  get(x,y){ return this.cells[(y+this.h)%this.h][(x+this.w)%this.w]; }
  set(x,y,v){ this.cells[(y+this.h)%this.h][(x+this.w)%this.w]=v; }
  clone(){ const g=new Grid(this.w,this.h); for(let y=0;y<this.h;y++) for(let x=0;x<this.w;x++) g.cells[y][x]=this.cells[y][x]; return g; }
  clear(){ for(let y=0;y<this.h;y++) for(let x=0;x<this.w;x++) this.cells[y][x]=0; }
}
window.Grid=Grid;
</script>

<script type="module">
// Neighbor helpers
const NEIGHBOR_DIRS=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];
function getNeighbors(boards,tensor,bi,x,y){
  const {gridW,gridH}=window.Config; let count=0;
  for(const [dx,dy] of NEIGHBOR_DIRS){ count+=boards[bi].get(x+dx,y+dy); }
  for(let bj=0;bj<boards.length;bj++){
    if(bi===bj) continue; const twist=tensor[bi]?.[bj]; if(!twist||twist==='0') continue;
    const [tx,ty]=applyTwist(x,y,twist);
    count+=boards[bj].get(tx,ty);
  }
  return count;
}
window.getNeighbors=getNeighbors;
window.NEIGHBOR_DIRS=NEIGHBOR_DIRS;
</script>

<script type="module">
// Twist helper
function applyTwist(x,y,twist){
  const {gridW,gridH}=window.Config;
  if(twist.includes('i')) x=gridW-1-x;
  if(parseFloat(twist)<0) y=gridH-1-y;
  return [(x+gridW)%gridW,(y+gridH)%gridH];
}
window.applyTwist=applyTwist;
</script>

<script type="module">
// Game class
class Game{
  constructor(n,tensor){ this.tensor=tensor; this.boards=[]; this.colorBuffers=[]; this.baseColors=[]; this.initBoards(n); }
  initBoards(n){ const {gridW,gridH}=window.Config; this.boards=[]; this.colorBuffers=[]; this.baseColors=[]; for(let i=0;i<n;i++){ const g=new Grid(gridW,gridH); g.randomize(0.2); this.boards.push(g); this.colorBuffers.push(new Float32Array(gridW*gridH*4)); this.baseColors.push({r:Math.random(),g:Math.random(),b:Math.random(),a:1}); } }
  step(){ const {gridW,gridH}=window.Config; const next=this.boards.map(b=>b.clone()); for(let bi=0;bi<this.boards.length;bi++){ for(let y=0;y<gridH;y++){ for(let x=0;x<gridW;x++){ const n=getNeighbors(this.boards,this.tensor,bi,x,y); const alive=this.boards[bi].get(x,y); next[bi].set(x,y,alive?(n===2||n===3?1:0):(n===3?1:0)); } } } this.boards=next; }
  updateColors(){ const {gridW,gridH,alphaDecay}=window.Config; for(let b=0;b<this.boards.length;b++){ const buf=this.colorBuffers[b]; const base=this.baseColors[b]; for(let i=0;i<buf.length;i++) buf[i]*=alphaDecay; for(let y=0;y<gridH;y++) for(let x=0;x<gridW;x++) if(this.boards[b].get(x,y)){ const idx=(y*gridW+x)*4; buf[idx]+=base.r*0.4; buf[idx+1]+=base.g*0.4; buf[idx+2]+=base.b*0.4; buf[idx+3]=1; } } }
}
window.Game=Game;
</script>

<script type="module">
// TensorGraph class
class TensorGraph{
  constructor(){ this.edges=new Map(); }
  addEdge(i,j,tw){ if(!this.edges.has(i)) this.edges.set(i,new Map()); this.edges.get(i).set(j,tw); }
  removeEdge(i,j){ if(this.edges.has(i)) this.edges.get(i).delete(j); }
  toMatrixString(n){ const rows=[]; for(let i=0;i<n;i++){ const row=[]; for(let j=0;j<n;j++){ const tw=this.edges.get(i)?.get(j)||'0'; row.push(tw); } rows.push(row.join('\t')); } return rows.join('\n'); }
  fromMatrixString(str){ this.edges=new Map(); const rows=str.trim().split(/\n+/); for(let i=0;i<rows.length;i++){ const cols=rows[i].trim().split(/\s+/); for(let j=0;j<cols.length;j++){ const v=cols[j]; if(v!=='0') this.addEdge(i,j,v); } } }
}
window.TensorGraph=TensorGraph;
</script>

<script type="module">
// UIManager
class UIManager{
  constructor(canvas,ctx,twistTextarea,graphSvg,speedSlider,toggleBtn,numInput,restartBtn,applyBtn){
    this.canvas=canvas; this.ctx=ctx; this.twistTextarea=twistTextarea; this.graphSvg=graphSvg; this.speedSlider=speedSlider; this.toggleBtn=toggleBtn; this.numInput=numInput; this.restartBtn=restartBtn; this.applyBtn=applyBtn; this.zoom=window.Config.defaultZoom; this.game=null; this.tensor=new TensorGraph(); }
  start(){ const n=parseInt(this.numInput.value)||window.Config.defaultBoardCount; this.tensor.fromMatrixString(this.twistTextarea.value||''); this.game=new Game(n,this.tensorToMatrix(n)); this.frame=0; requestAnimationFrame(()=>this.animate()); }
  tensorToMatrix(n){ const m=[]; for(let i=0;i<n;i++){ m[i]=[]; for(let j=0;j<n;j++){ m[i][j]='0'; } } for(const [i,map] of this.tensor.edges){ for(const [j,tw] of map){ m[i][j]=tw; } } return m; }
  animate(){ if(!this.game){ requestAnimationFrame(()=>this.animate()); return; } if(this.frame%parseInt(this.speedSlider.value)===0){ this.game.step(); this.game.updateColors(); } this.draw(); this.frame++; requestAnimationFrame(()=>this.animate()); }
  draw(){ const {gridW,gridH,cellSize}=window.Config; const bufW=gridW, bufH=gridH; this.ctx.canvas.width=gridW*cellSize; this.ctx.canvas.height=gridH*cellSize; for(let b=0;b<this.game.boards.length;b++){ const buf=this.game.colorBuffers[b]; for(let y=0;y<bufH;y++){ for(let x=0;x<bufW;x++){ const idx=(y*bufW+x)*4; const r=buf[idx]; const g=buf[idx+1]; const bl=buf[idx+2]; const a=buf[idx+3]; if(a>0.01){ this.ctx.fillStyle=`rgba(${r*255},${g*255},${bl*255},${a})`; this.ctx.fillRect(x*cellSize,y*cellSize,cellSize,cellSize); } } } } }
}
window.UIManager=UIManager;
</script>

<script type="module">
// drawGraph
function drawGraph(svg,tensor,n){ while(svg.firstChild) svg.removeChild(svg.firstChild); const width=svg.viewBox.baseVal.width||svg.width.baseVal.value; const height=svg.viewBox.baseVal.height||svg.height.baseVal.value; const r=15; const step=width/(n+1); const nodes=[]; for(let i=0;i<n;i++){ const cx=(i+1)*step; const cy=height/2; const circle=document.createElementNS('http://www.w3.org/2000/svg','circle'); circle.setAttribute('cx',cx); circle.setAttribute('cy',cy); circle.setAttribute('r',r); circle.setAttribute('fill','#333'); circle.setAttribute('stroke','#aaa'); svg.appendChild(circle); const text=document.createElementNS('http://www.w3.org/2000/svg','text'); text.setAttribute('x',cx); text.setAttribute('y',cy+4); text.setAttribute('fill','#eee'); text.setAttribute('text-anchor','middle'); text.textContent=i; svg.appendChild(text); nodes.push({x:cx,y:cy}); }
 for(const [i,map] of tensor.edges){ for(const [j,tw] of map){ const line=document.createElementNS('http://www.w3.org/2000/svg','line'); line.setAttribute('x1',nodes[i].x); line.setAttribute('y1',nodes[i].y); line.setAttribute('x2',nodes[j].x); line.setAttribute('y2',nodes[j].y); line.setAttribute('stroke','#0f0'); svg.appendChild(line); const tx=(nodes[i].x+nodes[j].x)/2; const ty=(nodes[i].y+nodes[j].y)/2; const t=document.createElementNS('http://www.w3.org/200/svg','text'); t.setAttribute('x',tx); t.setAttribute('y',ty-4); t.setAttribute('fill','#f0f'); t.setAttribute('text-anchor','middle'); t.textContent=tw; svg.appendChild(t); } }
}
window.drawGraph=drawGraph;
</script>

<script type="module">
// DOM Binding and entry
const canvas=document.getElementById('mainCanvas');
const ctx=canvas.getContext('2d');
const numInput=document.getElementById('numBoards');
const twistInput=document.getElementById('twistInput');
const restartBtn=document.getElementById('restartBtn');
const applyTwistBtn=document.getElementById('applyTwistBtn');
const toggleUIBtn=document.getElementById('toggleUIBtn');
const speedSlider=document.getElementById('speedSlider');
const graphSvg=document.getElementById('graphView');

const manager=new UIManager(canvas,ctx,twistInput,graphSvg,speedSlider,toggleUIBtn,numInput,restartBtn,applyTwistBtn);
restartBtn.onclick=()=>manager.start();
applyTwistBtn.onclick=()=>{ manager.tensor.fromMatrixString(twistInput.value); drawGraph(graphSvg,manager.tensor,parseInt(numInput.value)); };
manager.start();
</script>
</body>
</html>
